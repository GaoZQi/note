# 项目5 物联网智慧交通实验

## 实验内容

### 任务1

复习烧录程序，实现红黄绿灯交替点亮。

要求1：绿灯亮5秒，变黄灯闪烁5次，变红灯亮3秒，变黄灯闪烁5次，最后变绿灯。

要求2：自行创意。

### 任务2

实现停车场/ETC闸口抬杆/落杆。

任务2-1：通过红外传感器检测到汽车到达门口，控制舵机**自动**抬杆放行，车走后，**自动**落杆。

任务2-2：通过红外传感器进行检测，当汽车到达闸口，控制**单片机发送数据给上位机，上位机接收到数据后，发送数据给单片机**，控制舵机抬杆放行，车走后，**上位机发送另一数据**，落杆。

!!! tip "参考资料"
    [单片机与上位机的串行通信|MCU加油站:material-link:](http://mcu.eetrend.com/blog/2021/100114915.html)

## 实验原理

### 红外传感器

#### 红外传感器原理

红外传感器工作原理是利用红外辐射的热效应，探测器的敏感元件吸收辐射能后引起温度升高，进而使某些有关物理参数发生变化，通过测量物理参数的变化来确定探测器所吸收的红外辐射。

### PWM控制舵机

## 实验代码

### 任务1

下面为自定义效果，可以修改宏定义和函数变量实现要求一。

```c title="led.c"
/*单片机晶振频率选用11.0592MHZ*/
#include "stc15.h"          //调用stc15w单片机头文件
#include "intrins.h"        //
#define uchar unsigned char //
#define uint  unsigned int  //
//////////////////////////////////IO名称定义
sbit PWM1  = P2 ^ 1; // 舵机1输出定义
sbit IR_IN = P5 ^ 5; // 红外传感器输入定义  检测到物体输出低电平
sbit RR    = P7 ^ 3; // 交通灯红灯定义      低电平点亮
sbit YY    = P7 ^ 2; // 交通灯黄灯定义      低电平点亮
sbit GG    = P7 ^ 1; // 交通灯绿灯定义      低电平点亮
sbit beep  = P4 ^ 0; // 蜂鸣器定义          有源蜂鸣等于低电平发声
//////////////////////////////////变量定义
uint Servo1PwmDat = 750; // 启动单片机时舵机落杆位置，落杆 = 750,（500-2500）对应角度0-180度
#define GREEN  1,1,0        // 定义绿灯
#define YELLOW 1,0,1    	// 定义黄灯
#define RED    0,1,1        // 定义红灯

#define ON  0,0,0 // 定义开
#define OFF 1,1,1 // 定义关

#define TIME_GREEN  10 // 绿灯时间
#define TIME_YELLOW 5  // 黄灯时间
#define TIME_RED    10  // 红灯时间

uint time = 0; // 定义时间
//////////////////////////////////延时子程
void DelayMs(uint ms)
{
    uint i, j;
    for (i = 0; i < 85; i++)
        for (j = 0; j < ms; j++)
            ;
}
/////////////////////////////////IO口、定时器、串口通讯波特率初始化
void init()
{
    //////////////////////////////////////////IO初始化
    P0M1 = 0x00;
    P0M0 = 0x00; // 设置为准双向口
    P1M1 = 0x00;
    P1M0 = 0x00; // 设置为准双向口
    P2M1 = 0x00;
    P2M0 = 0x00; // 设置为准双向口
    P3M1 = 0x00;
    P3M0 = 0x00; // 设置为准双向口
    P4M1 = 0x00;
    P4M0 = 0x00; // 设置为准双向口
    P5M1 = 0x00;
    P5M0 = 0x00; // 设置为准双向口
    /////////////////////////////////////////舵机使用定时器T0初始
    TMOD &= 0xF0; // 设置定时器模式
    TMOD |= 0x01; // 设置定时器模式
    TL0 = 0x00;   // 设置定时初值
    TH0 = 0x00;   // 设置定时初值
    TF0 = 0;      // 清除TF0标志
    TR0 = 1;      // 定时器0开始计时
    ET0 = 1;      // 开定时器0中断
    /////////////////////////////////////////定时器T1   10毫秒@11.0592MHz
    AUXR &= 0x7F; // 定时器时钟12T模式
    TMOD &= 0xF0; // 设置定时器模式
    TL1 = 0x00;   // 设置定时初始值
    TH1 = 0xDC;   // 设置定时初始值
    ET1 = 1;      // 允许定时器T1产生中断
    TR1 = 1;      // 定时器1开始计时
    ///////////////////////////////定时器T2 串口通讯设置波特率9600bps@11.0592MHz
    /* SCON = 0x50;		               //8位数据,可变波特率
    AUXR |= 0x01;		             //串口1选择定时器2为波特率发生器
    AUXR &= 0xFB;		             //定时器时钟12T模式
    T2L = 0xE8;		               //设置定时初始值
    T2H = 0xFF;	 	               //设置定时初始值
    AUXR |= 0x10;		             //定时器2开始计时*/
}
///////////////////////////////////////////////舵机使用定时器0计数器赋值产生定时中断
void Timer0(uint pwm) // 11.0592Mhz晶振，12分频，所以计数器每递增一个数就是接近1微秒，
{
    uint value;
    value = 65535 - pwm;
    TR0   = 0;          // 关闭定时器T0
    TL0   = value;      // 16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
    TH0   = value >> 8; // 将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数据
    TR0   = 1;          // 启动定时器T0
}
///////////////////////////////////////////////
void led(uint r, uint y, uint g)    //点灯函数
{
	RR = r;
	YY = y;
	GG = g;
}
void flash(uint r, uint y, uint g)  //闪烁函数
{
    led(r, y, g);
    beep = 0;
    DelayMs(1000);
    led(OFF);
    beep = 1;
    DelayMs(1000);
}
///////////////////////////////////////////////
void led_time() //利用if控制交通灯时间
{
	if(time>0&&time<=TIME_GREEN)
	{
		led(GREEN);
        if(time>=TIME_GREEN-3)
        {
            flash(GREEN);
        }
	}
	if(time>TIME_GREEN&&time<=(TIME_GREEN+TIME_YELLOW))
	{
		flash(YELLOW);
	}
	if(time>(TIME_GREEN+TIME_YELLOW)&&time<=(TIME_YELLOW+TIME_GREEN+TIME_RED))
	{
		led(RED);
	}
	if(time>(TIME_GREEN+TIME_RED+TIME_YELLOW)&&time<=(TIME_YELLOW+TIME_GREEN+TIME_RED+TIME_YELLOW))
	{
        flash(YELLOW);
	}
	if(time>(TIME_GREEN+TIME_YELLOW+TIME_RED+TIME_YELLOW)&&time<=(TIME_YELLOW+TIME_GREEN+TIME_RED+TIME_YELLOW+TIME_GREEN))
	{
		led(GREEN);
        if(time>=(TIME_GREEN+TIME_YELLOW+TIME_RED+TIME_YELLOW+TIME_GREEN-3))
        {
            flash(GREEN);
        }
	}
    if (time > (TIME_GREEN + TIME_YELLOW + TIME_RED + TIME_YELLOW) && time <= (TIME_YELLOW + TIME_GREEN + TIME_RED + TIME_YELLOW + TIME_GREEN)) {
        time=0;
    }
}
//////////////////////////////////////////////主程序
void main()
{
    ES = 1; // 开串口中断
    EA = 1; // 打开总中断
    init(); // 调用初始化程序
    RR = 0;
    YY = 0;
    GG = 0;

    while (1) {
		led_time();
        // if (IR_IN == 0) {
        // }
    }
}
//////////////////////////////////////////////定时器T0中断处理
void Timer0_isr() interrupt 1
{
    static uint i = 1; // 静态变量：每次调用函数时保持上一次所赋的值
    switch (i) {
        case 1:
            PWM1 = 1; // PWM1控制舵机脚高电平输出
            Timer0(Servo1PwmDat);
            break; // 给定时器0赋值，计数Pwm1Dat个脉冲后产生中断，下次中断会进入下一个case语句

        case 2:
            PWM1 = 0; // PWM控制舵机脚低电平
            Timer0(20000 - Servo1PwmDat);
            i = 0;
            break;
            // 高脉冲结束后剩下的时间(20000-Pwm1Dat)全是低电平了，Pwm1Dat + (20000-Pwm1Dat) = 20000个脉冲正好为一个周期20毫秒
    }
    i++;
}
//////////////////////////////////////////////定时器T1中断处理，每10ms进入一次
void Timer1_isr() interrupt 3
{
    static char t=0;
    t++;
    if (t == 100) // 10ms*100=1s
    {
        t = 0; // 清零
		time++;
    }
}
```

### 任务2-1

利用PWM控制舵机选择到特定角度，基于已知框架，仅需要添加对红外传感器数值的判断即可。

```c title="2-1.c" hl_lines="84-89"
/*单片机晶振频率选用11.0592MHZ*/
#include "stc15.h"          //调用stc15w单片机头文件
#include "intrins.h"        //
#define uchar unsigned char //
#define uint  unsigned int  //
//////////////////////////////////IO名称定义
sbit PWM1  = P2 ^ 1; // 舵机1输出定义
sbit IR_IN = P5 ^ 5; // 红外传感器输入定义  检测到物体输出低电平
sbit RR    = P7 ^ 3; // 交通灯红灯定义      低电平点亮
sbit YY    = P7 ^ 2; // 交通灯黄灯定义      低电平点亮
sbit GG    = P7 ^ 1; // 交通灯绿灯定义      低电平点亮
sbit beep  = P4 ^ 0; // 蜂鸣器定义          有源蜂鸣等于低电平发声
//////////////////////////////////变量定义
uint Servo1PwmDat = 750; // 启动单片机时舵机落杆位置，落杆 = 750,（500-2500）对应角度0-180度

//////////////////////////////////延时子程
void DelayMs(uint ms)
{
    uint i, j;
    for (i = 0; i < 85; i++)
        for (j = 0; j < ms; j++)
            ;
}
/////////////////////////////////IO口、定时器、串口通讯波特率初始化
void init()
{
    //////////////////////////////////////////IO初始化
    P0M1 = 0x00;
    P0M0 = 0x00; // 设置为准双向口
    P1M1 = 0x00;
    P1M0 = 0x00; // 设置为准双向口
    P2M1 = 0x00;
    P2M0 = 0x00; // 设置为准双向口
    P3M1 = 0x00;
    P3M0 = 0x00; // 设置为准双向口
    P4M1 = 0x00;
    P4M0 = 0x00; // 设置为准双向口
    P5M1 = 0x00;
    P5M0 = 0x00; // 设置为准双向口
    /////////////////////////////////////////舵机使用定时器T0初始
    TMOD &= 0xF0; // 设置定时器模式
    TMOD |= 0x01; // 设置定时器模式
    TL0 = 0x00;   // 设置定时初值
    TH0 = 0x00;   // 设置定时初值
    TF0 = 0;      // 清除TF0标志
    TR0 = 1;      // 定时器0开始计时
    ET0 = 1;      // 开定时器0中断
    /////////////////////////////////////////定时器T1   10毫秒@11.0592MHz
    AUXR &= 0x7F; // 定时器时钟12T模式
    TMOD &= 0xF0; // 设置定时器模式
    TL1 = 0x00;   // 设置定时初始值
    TH1 = 0xDC;   // 设置定时初始值
    ET1 = 1;      // 允许定时器T1产生中断
    TR1 = 1;      // 定时器1开始计时
    ///////////////////////////////定时器T2 串口通讯设置波特率9600bps@11.0592MHz
    // SCON = 0x50;  // 8位数据,可变波特率
    // AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
    // AUXR &= 0xFB; // 定时器时钟12T模式
    // T2L = 0xE8;   // 设置定时初始值
    // T2H = 0xFF;   // 设置定时初始值
    // AUXR |= 0x10; // 定时器2开始计时
}
///////////////////////////////////////////////舵机使用定时器0计数器赋值产生定时中断
void Timer0(uint pwm) // 11.0592Mhz晶振，12分频，所以计数器每递增一个数就是接近1微秒，
{
    uint value;
    value = 65535 - pwm;
    TR0   = 0;          // 关闭定时器T0
    TL0   = value;      // 16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
    TH0   = value >> 8; // 将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数据
    TR0   = 1;          // 启动定时器T0
}
//////////////////////////////////////////////主程序
void main()
{
    ES = 1; // 开串口中断
    EA = 1; // 打开总中断
    init(); // 调用初始化程序
    while (1) {
        RR = 0;
        YY = 0;
        GG = 0;

        if (IR_IN == 0) {
            Servo1PwmDat = 1500;
        } else {
            DelayMs(10000); //延时落杠 (1)
            Servo1PwmDat = 750;
        }
    }
}
//////////////////////////////////////////////定时器T0中断处理
void Timer0_isr() interrupt 1
{
    static uint i = 1; // 静态变量：每次调用函数时保持上一次所赋的值
    switch (i) {
        case 1:
            PWM1 = 1; // PWM1控制舵机脚高电平输出
            Timer0(Servo1PwmDat);
            break; // 给定时器0赋值，计数Pwm1Dat个脉冲后产生中断，下次中断会进入下一个case语句

        case 2:
            PWM1 = 0; // PWM控制舵机脚低电平
            Timer0(20000 - Servo1PwmDat);
            i = 0;
            break;
            // 高脉冲结束后剩下的时间(20000-Pwm1Dat)全是低电平了，Pwm1Dat + (20000-Pwm1Dat) = 20000个脉冲正好为一个周期20毫秒
    }
    i++;
}
//////////////////////////////////////////////定时器T1中断处理，每10ms进入一次
void Timer1_isr() interrupt 3
{
    static char t;
    t++;
    if (t == 100) // 10ms*100=1s
    {
        t = 0; // 清零
    }
}
```

1. 因为器材原因，需要根据速度自行调整延时。

### 任务2-2

根据参考资料和串口通信框架，添加接收发语句并判断红外探测器状态，即可实现。

```c title="2-2.c" hl_lines="90-106"
/*单片机晶振频率选用11.0592MHZ*/
#include "stc15.h"          //调用stc15w单片机头文件
#include "intrins.h"        //
#define uchar unsigned char //
#define uint  unsigned int  //
//////////////////////////////////IO名称定义
sbit PWM1 = P2 ^ 1; // 舵机1输出定义
// sbit   PWM2 = P2^1;             //舵机2输出定义
sbit IR_IN = P5 ^ 5; // 红外传感器输入定义  检测到物体输出低电平
sbit RR    = P7 ^ 3; // 交通灯红灯定义      低电平点亮
sbit YY    = P7 ^ 2; // 交通灯黄灯定义      低电平点亮
sbit GG    = P7 ^ 1; // 交通灯绿灯定义      低电平点亮
sbit beep  = P4 ^ 0; // 蜂鸣器定义          有源蜂鸣等于低电平发声
//////////////////////////////////变量定义
uint Servo1PwmDat = 750; // 抬杆 =1700，落杆 = 750 启动单片机时舵机落杆位置，（500-2500）对应角度0-180度

uchar PC_dat; // 接收电脑发送过的存储变量

//////////////////////////////////延时子程
void DelayMs(uint ms)
{
    uint i, j;
    for (i = 0; i < 85; i++)
        for (j = 0; j < ms; j++)
            ;
}
//////////////////////////////////串口发送子程序（单片机发送十六进制数给电脑）
void uart_fa(uchar dat)
{
    SBUF = dat;
    while (!TI)
        ;
    TI = 0;
}
/////////////////////////////////IO口、定时器、串口通讯波特率初始化
void init()
{
    //////////////////////////////////////////IO初始化
    P0M1 = 0x00;
    P0M0 = 0x00; // 设置为准双向口
    P1M1 = 0x00;
    P1M0 = 0x00; // 设置为准双向口
    P2M1 = 0x00;
    P2M0 = 0x00; // 设置为准双向口
    P3M1 = 0x00;
    P3M0 = 0x00; // 设置为准双向口
    P4M1 = 0x00;
    P4M0 = 0x00; // 设置为准双向口
    P5M1 = 0x00;
    P5M0 = 0x00; // 设置为准双向口
    /////////////////////////////////////////舵机使用定时器T0初始
    TMOD &= 0xF0; // 设置定时器模式
    TMOD |= 0x01; // 设置定时器模式
    TL0 = 0x00;   // 设置定时初值
    TH0 = 0x00;   // 设置定时初值
    TF0 = 0;      // 清除TF0标志
    TR0 = 1;      // 定时器0开始计时
    ET0 = 1;      // 开定时器0中断
    /////////////////////////////////////////定时器T1   10毫秒@11.0592MHz
    AUXR &= 0x7F; // 定时器时钟12T模式
    TMOD &= 0xF0; // 设置定时器模式
    TL1 = 0x00;   // 设置定时初始值
    TH1 = 0xDC;   // 设置定时初始值
    ET1 = 1;      // 允许定时器T1产生中断
    TR1 = 1;      // 定时器1开始计时
    ///////////////////////////////定时器T2 串口通讯设置波特率9600bps@11.0592MHz
    SCON = 0x50;  // 8位数据,可变波特率
    AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
    AUXR &= 0xFB; // 定时器时钟12T模式
    T2L = 0xE8;   // 设置定时初始值
    T2H = 0xFF;   // 设置定时初始值
    AUXR |= 0x10; // 定时器2开始计时
}
///////////////////////////////////////////////舵机使用定时器0计数器赋值产生定时中断
void Timer0(uint pwm) // 11.0592Mhz晶振，12分频，所以计数器每递增一个数就是接近1微秒，
{
    uint value;
    value = 65535 - pwm;
    TR0   = 0;          // 关闭定时器T0
    TL0   = value;      // 16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
    TH0   = value >> 8; // 将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数据
    TR0   = 1;          // 启动定时器T0
}
//////////////////////////////////////////////主程序
void main()
{
    ES = 1; // 开串口中断
    EA = 1; // 打开总中断
    init(); // 调用初始化程序
    while (1) {
        if(IR_IN==0)
        {
            ES = 0; // 关闭串口中断 (1)
            TI = 0; //关闭读取
            uart_fa('a');   //发送字符 (2)
            ES = 1; //打开串口中断，接收指令
        }
        if(PC_dat=='1') //抬杆
        {
            Servo1PwmDat = 1500;
        }
        if(PC_dat=='2') //落杆
        {
            Servo1PwmDat = 750;
        }
    }
}
//////////////////////////////////////////////定时器T0中断处理
void Timer0_isr() interrupt 1
{
    static uint i = 1; // 静态变量：每次调用函数时保持上一次所赋的值
    switch (i) {
        case 1:
            PWM1 = 1; // PWM1控制舵机脚高电平输出
            Timer0(Servo1PwmDat);
            break; // 给定时器0赋值，计数Pwm1Dat个脉冲后产生中断，下次中断会进入下一个case语句

        case 2:
            PWM1 = 0; // PWM控制舵机脚低电平
            Timer0(20000 - Servo1PwmDat);
            i = 0;
            break;
            // 高脉冲结束后剩下的时间(20000-Pwm1Dat)全是低电平了，Pwm1Dat + (20000-Pwm1Dat) = 20000个脉冲正好为一个周期20毫秒
    }
    i++;
}
//////////////////////////////////////////////定时器T1中断处理，每10ms进入一次
void Timer1_isr() interrupt 3
{
    static char t;
    t++;
    if (t == 100) // 10ms*100=1s
    {
        t = 0; // 清零
    }
}
///////////////////////////////////////////串口接收中断（接收电脑发送过来的十六进制指令）
void Uart_1() interrupt 4
{
    if (RI) // 等待串口指令是否接收完，接收完RI就等于1
    {
        RI     = 0;    // 软件让RI置零
        PC_dat = SBUF; // 把电脑发过来的指令存放到PC_dat
    }
}

```

1. 不关闭串口终端会导致无法接收数据。
2. 如果收到数据有误，可以修改波特率，此设备为9600.
