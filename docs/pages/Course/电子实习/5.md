# 项目5 物联网智慧交通实验

## 实验内容

## 实验原理

### 红外传感器

#### 红外传感器原理

红外传感器工作原理是利用红外辐射的热效应，探测器的敏感元件吸收辐射能后引起温度升高，进而使某些有关物理参数发生变化，通过测量物理参数的变化来确定探测器所吸收的红外辐射。

### PWM控制舵机

## 实验代码

### 任务1

### 任务2-1

```c
/*单片机晶振频率选用11.0592MHZ*/
#include "stc15.h"          //调用stc15w单片机头文件
#include "intrins.h"        //
#define uchar unsigned char //
#define uint  unsigned int  //
//////////////////////////////////IO名称定义
sbit PWM1  = P2 ^ 1; // 舵机1输出定义
sbit IR_IN = P5 ^ 5; // 红外传感器输入定义  检测到物体输出低电平
sbit RR    = P7 ^ 3; // 交通灯红灯定义      低电平点亮
sbit YY    = P7 ^ 2; // 交通灯黄灯定义      低电平点亮
sbit GG    = P7 ^ 1; // 交通灯绿灯定义      低电平点亮
sbit beep  = P4 ^ 0; // 蜂鸣器定义          有源蜂鸣等于低电平发声
//////////////////////////////////变量定义
uint Servo1PwmDat = 750; // 启动单片机时舵机落杆位置，落杆 = 750,（500-2500）对应角度0-180度

//////////////////////////////////延时子程
void DelayMs(uint ms)
{
    uint i, j;
    for (i = 0; i < 85; i++)
        for (j = 0; j < ms; j++)
            ;
}
/////////////////////////////////IO口、定时器、串口通讯波特率初始化
void init()
{
    //////////////////////////////////////////IO初始化
    P0M1 = 0x00;
    P0M0 = 0x00; // 设置为准双向口
    P1M1 = 0x00;
    P1M0 = 0x00; // 设置为准双向口
    P2M1 = 0x00;
    P2M0 = 0x00; // 设置为准双向口
    P3M1 = 0x00;
    P3M0 = 0x00; // 设置为准双向口
    P4M1 = 0x00;
    P4M0 = 0x00; // 设置为准双向口
    P5M1 = 0x00;
    P5M0 = 0x00; // 设置为准双向口
    /////////////////////////////////////////舵机使用定时器T0初始
    TMOD &= 0xF0; // 设置定时器模式
    TMOD |= 0x01; // 设置定时器模式
    TL0 = 0x00;   // 设置定时初值
    TH0 = 0x00;   // 设置定时初值
    TF0 = 0;      // 清除TF0标志
    TR0 = 1;      // 定时器0开始计时
    ET0 = 1;      // 开定时器0中断
    /////////////////////////////////////////定时器T1   10毫秒@11.0592MHz
    AUXR &= 0x7F; // 定时器时钟12T模式
    TMOD &= 0xF0; // 设置定时器模式
    TL1 = 0x00;   // 设置定时初始值
    TH1 = 0xDC;   // 设置定时初始值
    ET1 = 1;      // 允许定时器T1产生中断
    TR1 = 1;      // 定时器1开始计时
    ///////////////////////////////定时器T2 串口通讯设置波特率9600bps@11.0592MHz
    // SCON = 0x50;  // 8位数据,可变波特率
    // AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
    // AUXR &= 0xFB; // 定时器时钟12T模式
    // T2L = 0xE8;   // 设置定时初始值
    // T2H = 0xFF;   // 设置定时初始值
    // AUXR |= 0x10; // 定时器2开始计时
}
///////////////////////////////////////////////舵机使用定时器0计数器赋值产生定时中断
void Timer0(uint pwm) // 11.0592Mhz晶振，12分频，所以计数器每递增一个数就是接近1微秒，
{
    uint value;
    value = 65535 - pwm;
    TR0   = 0;          // 关闭定时器T0
    TL0   = value;      // 16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
    TH0   = value >> 8; // 将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数据
    TR0   = 1;          // 启动定时器T0
}
//////////////////////////////////////////////主程序
void main()
{
    ES = 1; // 开串口中断
    EA = 1; // 打开总中断
    init(); // 调用初始化程序
    while (1) {
        RR = 0;
        YY = 0;
        GG = 0;

        if (IR_IN == 0) {
            Servo1PwmDat = 1500;
        } else {
            DelayMs(10000);
            Servo1PwmDat = 750;
        }
    }
}
//////////////////////////////////////////////定时器T0中断处理
void Timer0_isr() interrupt 1
{
    static uint i = 1; // 静态变量：每次调用函数时保持上一次所赋的值
    switch (i) {
        case 1:
            PWM1 = 1; // PWM1控制舵机脚高电平输出
            Timer0(Servo1PwmDat);
            break; // 给定时器0赋值，计数Pwm1Dat个脉冲后产生中断，下次中断会进入下一个case语句

        case 2:
            PWM1 = 0; // PWM控制舵机脚低电平
            Timer0(20000 - Servo1PwmDat);
            i = 0;
            break;
            // 高脉冲结束后剩下的时间(20000-Pwm1Dat)全是低电平了，Pwm1Dat + (20000-Pwm1Dat) = 20000个脉冲正好为一个周期20毫秒
    }
    i++;
}
//////////////////////////////////////////////定时器T1中断处理，每10ms进入一次
void Timer1_isr() interrupt 3
{
    static char t;
    t++;
    if (t == 100) // 10ms*100=1s
    {
        t = 0; // 清零
    }
}
```

### 任务2-2

```c
/*单片机晶振频率选用11.0592MHZ*/
#include "stc15.h"          //调用stc15w单片机头文件
#include "intrins.h"        //
#define uchar unsigned char //
#define uint  unsigned int  //
//////////////////////////////////IO名称定义
sbit PWM1 = P2 ^ 1; // 舵机1输出定义
// sbit   PWM2 = P2^1;             //舵机2输出定义
sbit IR_IN = P5 ^ 5; // 红外传感器输入定义  检测到物体输出低电平
sbit RR    = P7 ^ 3; // 交通灯红灯定义      低电平点亮
sbit YY    = P7 ^ 2; // 交通灯黄灯定义      低电平点亮
sbit GG    = P7 ^ 1; // 交通灯绿灯定义      低电平点亮
sbit beep  = P4 ^ 0; // 蜂鸣器定义          有源蜂鸣等于低电平发声
//////////////////////////////////变量定义
uint Servo1PwmDat = 750; // 抬杆 =1700，落杆 = 750 启动单片机时舵机落杆位置，（500-2500）对应角度0-180度

uchar PC_dat; // 接收电脑发送过的存储变量

//////////////////////////////////延时子程
void DelayMs(uint ms)
{
    uint i, j;
    for (i = 0; i < 85; i++)
        for (j = 0; j < ms; j++)
            ;
}
//////////////////////////////////串口发送子程序（单片机发送十六进制数给电脑）
void uart_fa(uchar dat)
{
    SBUF = dat;
    while (!TI)
        ;
    TI = 0;
}
/////////////////////////////////IO口、定时器、串口通讯波特率初始化
void init()
{
    //////////////////////////////////////////IO初始化
    P0M1 = 0x00;
    P0M0 = 0x00; // 设置为准双向口
    P1M1 = 0x00;
    P1M0 = 0x00; // 设置为准双向口
    P2M1 = 0x00;
    P2M0 = 0x00; // 设置为准双向口
    P3M1 = 0x00;
    P3M0 = 0x00; // 设置为准双向口
    P4M1 = 0x00;
    P4M0 = 0x00; // 设置为准双向口
    P5M1 = 0x00;
    P5M0 = 0x00; // 设置为准双向口
    /////////////////////////////////////////舵机使用定时器T0初始
    TMOD &= 0xF0; // 设置定时器模式
    TMOD |= 0x01; // 设置定时器模式
    TL0 = 0x00;   // 设置定时初值
    TH0 = 0x00;   // 设置定时初值
    TF0 = 0;      // 清除TF0标志
    TR0 = 1;      // 定时器0开始计时
    ET0 = 1;      // 开定时器0中断
    /////////////////////////////////////////定时器T1   10毫秒@11.0592MHz
    AUXR &= 0x7F; // 定时器时钟12T模式
    TMOD &= 0xF0; // 设置定时器模式
    TL1 = 0x00;   // 设置定时初始值
    TH1 = 0xDC;   // 设置定时初始值
    ET1 = 1;      // 允许定时器T1产生中断
    TR1 = 1;      // 定时器1开始计时
    ///////////////////////////////定时器T2 串口通讯设置波特率9600bps@11.0592MHz
    SCON = 0x50;  // 8位数据,可变波特率
    AUXR |= 0x01; // 串口1选择定时器2为波特率发生器
    AUXR &= 0xFB; // 定时器时钟12T模式
    T2L = 0xE8;   // 设置定时初始值
    T2H = 0xFF;   // 设置定时初始值
    AUXR |= 0x10; // 定时器2开始计时
}
///////////////////////////////////////////////舵机使用定时器0计数器赋值产生定时中断
void Timer0(uint pwm) // 11.0592Mhz晶振，12分频，所以计数器每递增一个数就是接近1微秒，
{
    uint value;
    value = 65535 - pwm;
    TR0   = 0;          // 关闭定时器T0
    TL0   = value;      // 16位数据给8位数据赋值默认将16位数据的低八位直接赋给八位数据
    TH0   = value >> 8; // 将16位数据右移8位，也就是将高8位移到低八位，再赋值给8位数据
    TR0   = 1;          // 启动定时器T0
}
//////////////////////////////////////////////主程序
void main()
{
    ES = 1; // 开串口中断
    EA = 1; // 打开总中断
    init(); // 调用初始化程序
    while (1) {
        if(IR_IN==0)
        {
            ES = 0; // 关闭串口中断
            TI = 0;
            uart_fa('a');
            ES = 1;
        }
        if(PC_dat=='1')
        {
            Servo1PwmDat = 1500;
        }
        if(PC_dat=='2')
        {
            Servo1PwmDat = 750;
        }
    }
}
//////////////////////////////////////////////定时器T0中断处理
void Timer0_isr() interrupt 1
{
    static uint i = 1; // 静态变量：每次调用函数时保持上一次所赋的值
    switch (i) {
        case 1:
            PWM1 = 1; // PWM1控制舵机脚高电平输出
            Timer0(Servo1PwmDat);
            break; // 给定时器0赋值，计数Pwm1Dat个脉冲后产生中断，下次中断会进入下一个case语句

        case 2:
            PWM1 = 0; // PWM控制舵机脚低电平
            Timer0(20000 - Servo1PwmDat);
            i = 0;
            break;
            // 高脉冲结束后剩下的时间(20000-Pwm1Dat)全是低电平了，Pwm1Dat + (20000-Pwm1Dat) = 20000个脉冲正好为一个周期20毫秒
    }
    i++;
}
//////////////////////////////////////////////定时器T1中断处理，每10ms进入一次
void Timer1_isr() interrupt 3
{
    static char t;
    t++;
    if (t == 100) // 10ms*100=1s
    {
        t = 0; // 清零
    }
}
///////////////////////////////////////////串口接收中断（接收电脑发送过来的十六进制指令）
void Uart_1() interrupt 4
{
    if (RI) // 等待串口指令是否接收完，接收完RI就等于1
    {
        RI     = 0;    // 软件让RI置零
        PC_dat = SBUF; // 把电脑发过来的指令存放到PC_dat
    }
}

```
